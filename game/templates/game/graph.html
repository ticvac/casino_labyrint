<!doctype html>
<html lang="cs">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Graph Editor — kresli a ulož</title>
<style>
  html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial}
  #graphCanvas{display:block;background:linear-gradient(#fbfcff,#f3f8ff);width:100vw;height:100vh}
  .controls{position:fixed;left:12px;top:12px;background:rgba(255,255,255,0.95);padding:8px;border-radius:10px;box-shadow:0 8px 24px rgba(0,0,0,0.08)}
  .controls button{margin:3px}
  .hint{color:#445; font-size:13px; margin-top:6px}
</style>
</head>
<body>
<canvas id="graphCanvas"></canvas>
<div class="controls">
  <button id="load">Načíst</button>
  <button id="save">Uložit</button>
  <button id="clear">Vyčistit</button>
  <span class="hint">Double‑click: vytvořit uzel · Click-drag: táhnout · Klik 2x: spojit (klik na uzel → klik na cílový uzel)</span>
</div>

<script defer>
/* Simple editable graph canvas that persists node positions to a Django backend.
   Usage:
   - Double-click on an empty area: vytvoří nový uzel (vyzve na identifikátor)
   - Drag node: přesune ho
   - Click a node once (select), then click jiný uzel: vytvoří hranu from->to
   - Save: POST /graph/save/ JSON {nodes:[{id,label,x,y}], edges:[{from,to}]}
   - Load: GET  /graph/json/  expected {nodes:[...], edges:[...]}
*/

const canvas = document.getElementById('graphCanvas');
const ctx = canvas.getContext('2d');
function resize(){canvas.width = window.innerWidth; canvas.height = window.innerHeight}
window.addEventListener('resize', resize); resize();

const NODE_R = 20;
let nodes = []; // {id,label,x,y}
let edges = []; // {from,to}

let dragging = null; let dragOffset = {x:0,y:0};
let selected = null; // for creating edge: first clicked node

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // edges
  ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(30,40,80,0.6)';
  for(const e of edges){
    const a = findNode(e.from); const b = findNode(e.to);
    if(!a||!b) continue;
    ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    // small arrow
    drawArrow(a,b);
  }
  // nodes
  for(const n of nodes){
    // shadow
    ctx.beginPath(); ctx.fillStyle = 'rgba(0,0,0,0.08)'; ctx.ellipse(n.x+3,n.y+5,NODE_R+6,NODE_R+6,0,0,Math.PI*2); ctx.fill();
    // circle
    ctx.beginPath(); ctx.fillStyle = (selected && selected.id === n.id) ? '#ffd' : '#fff'; ctx.strokeStyle = '#2774a6'; ctx.lineWidth = 2; ctx.ellipse(n.x,n.y,NODE_R,NODE_R,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
    // label
    ctx.fillStyle = '#123'; ctx.font = '13px system-ui,Segoe UI,Roboto'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(n.label||n.id, n.x, n.y);
    drawVisitsUnderNode(n);
  }
}

function drawArrow(a,b){
  const dx = b.x - a.x, dy = b.y - a.y; const len = Math.sqrt(dx*dx+dy*dy)||1;
  const ux = dx/len, uy = dy/len;
  const px = b.x - ux*(NODE_R+6), py = b.y - uy*(NODE_R+6);
  const size = 7;
  const ang = Math.atan2(uy, ux);
  ctx.save(); ctx.translate(px,py); ctx.rotate(ang);
  ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-size, size/2); ctx.lineTo(-size, -size/2); ctx.closePath(); ctx.fillStyle='rgba(30,40,80,0.7)'; ctx.fill(); ctx.restore();
}

function findNode(id){ return nodes.find(n=>n.id===id); }
function nodeAt(pos){ return nodes.find(n=>{const dx=pos.x-n.x, dy=pos.y-n.y; return dx*dx+dy*dy <= (NODE_R+4)*(NODE_R+4) }); }

function getPointerPos(ev){ const r = canvas.getBoundingClientRect(); return {x: ev.clientX - r.left, y: ev.clientY - r.top}; }

canvas.addEventListener('dblclick', (ev)=>{
  const pos = getPointerPos(ev);
  // check if on node
  if(nodeAt(pos)) return; // ignore
  let id = prompt('Zadej identifikátor uzlu (unikátní):', 'node_' + Date.now());
  if(!id) return;
  // if id exists, append suffix
  if(findNode(id)) id = id + '_' + Math.floor(Math.random()*1000);
  nodes.push({id:id, label:id, x:pos.x, y:pos.y});
  draw();
});

canvas.addEventListener('pointerdown', (ev)=>{
  const pos = getPointerPos(ev);
  const n = nodeAt(pos);
  if(n){
    // start dragging
    dragging = n; dragOffset.x = pos.x - n.x; dragOffset.y = pos.y - n.y;
    canvas.setPointerCapture(ev.pointerId);
    // selection/click: if there's already selected node and it's different -> create edge
    if(selected && selected.id !== n.id){
      // create edge from selected -> n
      edges.push({from:selected.id, to:n.id});
      selected = null; draw();
      return;
    }
    // otherwise toggle selection
    selected = (selected && selected.id===n.id) ? null : n;
    draw();
  } else {
    // clicked empty space: clear selection
    selected = null; draw();
  }
});

canvas.addEventListener('pointermove', (ev)=>{
  if(!dragging) return;
  const pos = getPointerPos(ev);
  dragging.x = pos.x - dragOffset.x; dragging.y = pos.y - dragOffset.y;
  draw();
});
canvas.addEventListener('pointerup', (ev)=>{ if(dragging){ dragging = null; } });

// UI buttons
document.getElementById('clear').addEventListener('click', ()=>{ if(confirm('Smazat všechny uzly a hrany?')){ nodes=[]; edges=[]; selected=null; draw(); } });
document.getElementById('load').addEventListener('click', loadFromServer);
document.getElementById('save').addEventListener('click', saveToServer);

async function loadFromServer(){
  try{
    const res = await fetch('/graph/json/');
    if(!res.ok) throw new Error('Network');
    const data = await res.json();
    nodes = (data.nodes||[]).map(n=>({id:n.id, label:n.label||n.id, x: parseFloat(n.x)||0, y: parseFloat(n.y)||0}));
    edges = (data.edges||[]).map(e=>({from:e.from, to:e.to}));
    selected = null; draw();
  }catch(err){ alert('Chyba při načítání: ' + err.message); }
}

function getCookie(name){
  // standardní helper pro CSRF token
  const v = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
  return v ? v.pop() : '';
}

async function saveToServer(){
  const payload = {nodes: nodes.map(n=>({id:n.id, label:n.label, x:n.x, y:n.y})), edges: edges};
  try{
    const res = await fetch('/graph/save/',{
      method:'POST',
      headers: {'Content-Type':'application/json', 'X-CSRFToken': getCookie('csrftoken')},
      body: JSON.stringify(payload)
    });
    if(!res.ok){
      const text = await res.text(); throw new Error(text||res.statusText);
    }
    alert('Uloženo.');
  }catch(err){ alert('Chyba při ukládání: '+err.message + ' (nezapomeň mít CSRF cookie a přihlášení pokud je vyžadováno)'); }
}

function stringToColor(str){
  // deterministická HSL barva podle jména
  let hash = 0;
  for (let i=0;i<str.length;i++){ hash = ((hash<<5)-hash) + str.charCodeAt(i); hash |= 0; }
  const h = Math.abs(hash) % 360;
  const s = 60 + (Math.abs(hash) % 20); // s 60-80
  const l = 45; // konstantní světlost
  return `hsl(${h} ${s}% ${l}%)`;
}

// --- parsování ISO času do epoch ms ---
function parseTime(t){ return t ? new Date(t).getTime() : 0; }

// --- počítá pro každého uživatele jeho poslední (nejnovější) návštěvu napříč všemi uzly ---
function computeUserLastVisitMap(allNodes){
  const map = new Map(); // username -> {time, nodeId}
  for(const n of allNodes){
    const visits = n.visits || [];
    for(const v of visits){
      if (v.type !== 1) continue; // jen SUCCESS
      const uname = v.user.username;
      const t = parseTime(v.visit_time);
      const prev = map.get(uname);
      if(!prev || t > prev.time) map.set(uname, {time: t, nodeId: n.id});
    }
  }
  return map;
}

// --- vykreslení teček pod uzlem ---
function drawVisitsUnderNode(node){
  const visits = (node.visits || []).filter(v=> v.type === 1); // SUCCESS only
  if(visits.length === 0) return;
  // z každého uživatele vezmeme pouze nejnovější návštěvu k tomuto uzlu
  const byUser = new Map();
  for(const v of visits){
    const u = v.user.username;
    const t = parseTime(v.visit_time);
    const prev = byUser.get(u);
    if(!prev || t > prev.time) byUser.set(u, {time: t, visit: v});
  }
  // převést na pole se seřazením podle času (starší vlevo)
  const arr = Array.from(byUser.values()).sort((a,b)=> a.time - b.time);

  // normalizace opacity v rozsahu 0.25..1.0 podle relativity v rámci tohoto uzlu
  const times = arr.map(x => x.time);
  const maxT = Math.max(...times);
  const minT = Math.min(...times);
  const span = Math.max(1, maxT - minT);

  // umístění: vykreslíme tečky vodorovně pod uzlem, centrované
  const spacing = 12;
  const dotBase = 6;
  const totalWidth = arr.length * spacing;
  let startX = node.x - totalWidth/2 + spacing/2;
  const y = node.y + NODE_R + 12;

    /*
        Spočítat celkový počet návštěv, které každý hráč provedl napříč všemi uzly.
        Výsledek: { username: count }
    */
    const totalVisitCounts = {};
    for (const n of nodes) {
        const vlist = (n.visits || []).filter(v => v.type === 1); // SUCCESS only
        for (const v of vlist) {
            const uname = v.user.username;
            totalVisitCounts[uname] = (totalVisitCounts[uname] || 0) + 1;
        }
    }

    let copy_of_totalVisitCounts = JSON.parse(JSON.stringify(totalVisitCounts));
    Object.keys(copy_of_totalVisitCounts).forEach(k => copy_of_totalVisitCounts[k] = 1);
    // hmm does not work... 
// console.log(copy_of_totalVisitCounts)

  for(let i=0;i<arr.length;i++){
    const u = arr[i];
    const username = u.visit.user.username;
    const totalCount = totalVisitCounts[username] || 1;
    const alpha = 1//0.1 + (0.9 / Math.max(1, totalCount - 1)) * copy_of_totalVisitCounts[username];
    copy_of_totalVisitCounts[username]++;
    const color = stringToColor(username);

    // zjistíme, jestli je tahle návštěva poslední návštěvou uživatele (globálně)
    const last = userLastVisitMap.get(username);
    const isUserLastHere = last && last.nodeId === node.id && last.time === u.time;

    const cx = startX + i*spacing;
    const r = isUserLastHere ? dotBase * 1.6 : dotBase;

    // plná kružnice
    ctx.beginPath();
    ctx.arc(cx, y, r, 0, Math.PI*2);
    ctx.fillStyle = color;
    ctx.globalAlpha = alpha;
    ctx.fill();
    ctx.globalAlpha = 1.0;

    // pokud je to uživatelova poslední návštěva, přidej zvýraznění (obvod)
    if(isUserLastHere){
      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.arc(cx, y, r + 2, 0, Math.PI*2);
      ctx.stroke();
        ctx.font = '11px system-ui,Segoe UI,Roboto';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillStyle = '#333';
        const dateStr = new Date(u.time).toLocaleString('cs-CZ', {hour:'2-digit', minute:'2-digit', day:'2-digit', month:'2-digit'});
        ctx.fillText(dateStr, cx, y + r + 4);
    }

    // malý tooltip při hover: (můžeš doplnit později)
  }
}

let userLastVisitMap = new Map();

async function loadFromServer(){
  try{
    const res = await fetch('/graph/json/');
    if(!res.ok) throw new Error('Network');
    const data = await res.json();
    // nodes mají nyní pole visits (máme stejné id/label/x/y jako dříve)
    nodes = (data.nodes || []).map(n=>({
      id: n.id, label: n.label||n.id, x: parseFloat(n.x)||0, y: parseFloat(n.y)||0, visits: n.visits || []
    }));
    edges = (data.edges||[]).map(e=>({from:e.from, to:e.to}));

    // spočítej poslední návštěvu pro každého uživatele (globálně)
    userLastVisitMap = computeUserLastVisitMap(nodes);
    selected = null; draw();
  }catch(err){ alert('Chyba při načítání: ' + err.message); }
}


// initial draw
draw();

</script>

<!--
Django (views.py) — vložte do svého appu. Nepoužívejte @csrf_exempt pokud frontend zasílá CSRF token.
-->

<!--
# views.py
from django.http import JsonResponse, HttpResponseBadRequest, HttpResponse
from django.views.decorators.http import require_POST, require_GET
from django.db import transaction
import json
from .models import GraphPoint

@require_GET
def graph_json(request):
    nodes = []
    edges = []
    for p in GraphPoint.objects.all():
        nodes.append({'id': p.identifier, 'label': p.default_name or p.identifier, 'x': float(p.x), 'y': float(p.y)})
        for q in p.next_points.all():
            edges.append({'from': p.identifier, 'to': q.identifier})
    return JsonResponse({'nodes': nodes, 'edges': edges})

@require_POST
def graph_save(request):
    try:
        payload = json.loads(request.body.decode('utf-8'))
    except Exception:
        return HttpResponseBadRequest('Invalid JSON')
    nodes = payload.get('nodes', [])
    edges = payload.get('edges', [])
    # save inside transaction
    with transaction.atomic():
        # create or update nodes
        instances = {}
        for n in nodes:
            ident = n.get('id')
            if not ident: continue
            obj, created = GraphPoint.objects.get_or_create(identifier=ident)
            obj.default_name = n.get('label') or ident
            obj.x = float(n.get('x') or 0)
            obj.y = float(n.get('y') or 0)
            obj.save()
            instances[ident] = obj
        # clear all next_points to set edges exactly as given
        # (alternatively: be incremental)
        GraphPoint.objects.update()  # noop but ensures model imported
        for obj in instances.values():
            obj.next_points.clear()
        # add edges
        for e in edges:
            f = e.get('from'); t = e.get('to')
            if f in instances and t in instances:
                instances[f].next_points.add(instances[t])
    return JsonResponse({'status': 'ok'})

# urls.py
# path('graph/json/', views.graph_json, name='graph-json')
# path('graph/save/', views.graph_save, name='graph-save')
-->

</body>
</html>
